# Arrays
    # - sorting
    # - binary search
    # - prefix sum
    # - sliding window


# Recursion: 
# - trees
# - decision trees
#   - intuition of solcing 


# Graph
    # DFS
    # BFS

#  HashMap
#  very useful for counting and building an adj list
#  O(1) for all operations: access, search, insertion, deletion
#  ASK: would a hashmap be useful here

# Heaps
# Peak: O(1)
# heapify: O(n) -> turns set of values into a heap
#   -> TO BE O(n) ALL VALUES MUST EXIST BEFORE HEAPIFY, ADDING ONE BY ONE IS O(nlogn)
# insertion: O(logn)
# deletion: O(logn)

# Dynamic Programming
# hard to learn, but not that common
# EX: Coin change, longest common subsequence 



# sliding window
# - use two pointers intelligently to iterate through an array in O(n)
# - ispalindrome is easiest example

# Binary search
# O(logn)


